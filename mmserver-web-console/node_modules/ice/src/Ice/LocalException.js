// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `LocalException.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

/* slice2js browser-bundle-skip */
(function(module, require, exports)
{
/* slice2js browser-bundle-skip-end */
/* slice2js browser-bundle-skip */
    var __M = require("../Ice/ModuleRegistry").Ice.__M;
    var Ice = __M.require(module, 
    [
        "../Ice/Exception",
        "../Ice/Long",
        "../Ice/HashMap",
        "../Ice/HashUtil",
        "../Ice/ArrayUtil",
        "../Ice/StreamHelpers",
        "../Ice/Identity",
        "../Ice/Version",
        "../Ice/BuiltinSequences"
    ]).Ice;
    
    var Slice = Ice.Slice;
/* slice2js browser-bundle-skip-end */

    /**
     * This exception is raised when a failure occurs during initialization.
     * 
     **/
    Ice.InitializationException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.reason = reason !== undefined ? reason : "";
        },
        Ice.LocalException,
        "Ice::InitializationException");

    /**
     * This exception indicates that a failure occurred while initializing
     * a plug-in.
     * 
     **/
    Ice.PluginInitializationException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.reason = reason !== undefined ? reason : "";
        },
        Ice.LocalException,
        "Ice::PluginInitializationException");

    /**
     * This exception is raised if a feature is requested that is not
     * supported with collocation optimization.
     * 
     * @deprecated this exception isn't used anymore by the Ice runtime
     **/
    Ice.CollocationOptimizationException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.LocalException.call(this, _cause);
        },
        Ice.LocalException,
        "Ice::CollocationOptimizationException");

    /**
     * An attempt was made to register something more than once with
     * the Ice run time.
     * 
     * This exception is raised if an attempt is made to register a
     * servant, servant locator, facet, object factory, plug-in, object
     * adapter, object, or user exception factory more than once for the
     * same ID.
     * 
     **/
    Ice.AlreadyRegisteredException = Slice.defineLocalException(
        function(kindOfObject, id, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.kindOfObject = kindOfObject !== undefined ? kindOfObject : "";
            this.id = id !== undefined ? id : "";
        },
        Ice.LocalException,
        "Ice::AlreadyRegisteredException");

    /**
     * An attempt was made to find or deregister something that is not
     * registered with the Ice run time or Ice locator.
     * 
     * This exception is raised if an attempt is made to remove a servant,
     * servant locator, facet, object factory, plug-in, object adapter,
     * object, or user exception factory that is not currently registered.
     * 
     * It's also raised if the Ice locator can't find an object or object
     * adapter when resolving an indirect proxy or when an object adapter
     * is activated.
     * 
     **/
    Ice.NotRegisteredException = Slice.defineLocalException(
        function(kindOfObject, id, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.kindOfObject = kindOfObject !== undefined ? kindOfObject : "";
            this.id = id !== undefined ? id : "";
        },
        Ice.LocalException,
        "Ice::NotRegisteredException");

    /**
     * The operation can only be invoked with a twoway request.
     * 
     * This exception is raised if an attempt is made to invoke an
     * operation with <tt>ice_oneway</tt>, <tt>ice_batchOneway</tt>, <tt>ice_datagram</tt>,
     * or <tt>ice_batchDatagram</tt> and the operation has a return value,
     * out-parameters, or an exception specification.
     * 
     **/
    Ice.TwowayOnlyException = Slice.defineLocalException(
        function(operation, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.operation = operation !== undefined ? operation : "";
        },
        Ice.LocalException,
        "Ice::TwowayOnlyException");

    /**
     * An attempt was made to clone a class that does not support
     * cloning.
     * 
     * This exception is raised if <tt>ice_clone</tt> is called on
     * a class that is derived from an abstract Slice class (that is,
     * a class containing operations), and the derived class does not
     * provide an implementation of the <tt>ice_clone</tt> operation (C++ only).
     * 
     **/
    Ice.CloneNotImplementedException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.LocalException.call(this, _cause);
        },
        Ice.LocalException,
        "Ice::CloneNotImplementedException");

    /**
     * This exception is raised if an operation call on a server raises an
     * unknown exception. For example, for C++, this exception is raised
     * if the server throws a C++ exception that is not directly or
     * indirectly derived from <tt>Ice::LocalException</tt> or
     * <tt>Ice::UserException</tt>.
     * 
     **/
    Ice.UnknownException = Slice.defineLocalException(
        function(unknown, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.unknown = unknown !== undefined ? unknown : "";
        },
        Ice.LocalException,
        "Ice::UnknownException");

    /**
     * This exception is raised if an operation call on a server raises a
     * local exception. Because local exceptions are not transmitted by
     * the Ice protocol, the client receives all local exceptions raised
     * by the server as {@link UnknownLocalException}. The only exception to this
     * rule are all exceptions derived from {@link RequestFailedException},
     * which are transmitted by the Ice protocol even though they are
     * declared <tt>local</tt>.
     * 
     **/
    Ice.UnknownLocalException = Slice.defineLocalException(
        function(unknown, _cause)
        {
            Ice.UnknownException.call(this, unknown, _cause);
        },
        Ice.UnknownException,
        "Ice::UnknownLocalException");

    /**
     * An operation raised an incorrect user exception.
     * 
     * This exception is raised if an operation raises a
     * user exception that is not declared in the exception's
     * <tt>throws</tt> clause. Such undeclared exceptions are
     * not transmitted from the server to the client by the Ice
     * protocol, but instead the client just gets an
     * {@link UnknownUserException}. This is necessary in order to not violate
     * the contract established by an operation's signature: Only local
     * exceptions and user exceptions declared in the
     * <tt>throws</tt> clause can be raised.
     * 
     **/
    Ice.UnknownUserException = Slice.defineLocalException(
        function(unknown, _cause)
        {
            Ice.UnknownException.call(this, unknown, _cause);
        },
        Ice.UnknownException,
        "Ice::UnknownUserException");

    /**
     * This exception is raised if the Ice library version does not match
     * the version in the Ice header files.
     * 
     **/
    Ice.VersionMismatchException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.LocalException.call(this, _cause);
        },
        Ice.LocalException,
        "Ice::VersionMismatchException");

    /**
     * This exception is raised if the {@link Communicator} has been destroyed.
     * 
     * @see Communicator#destroy
     * 
     **/
    Ice.CommunicatorDestroyedException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.LocalException.call(this, _cause);
        },
        Ice.LocalException,
        "Ice::CommunicatorDestroyedException");

    /**
     * This exception is raised if an attempt is made to use a deactivated
     * {@link ObjectAdapter}.
     * 
     * @see ObjectAdapter#deactivate
     * @see Communicator#shutdown
     * 
     **/
    Ice.ObjectAdapterDeactivatedException = Slice.defineLocalException(
        function(name, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.name = name !== undefined ? name : "";
        },
        Ice.LocalException,
        "Ice::ObjectAdapterDeactivatedException");

    /**
     * This exception is raised if an {@link ObjectAdapter} cannot be activated.
     * 
     * This happens if the {@link Locator} detects another active {@link ObjectAdapter} with
     * the same adapter id.
     * 
     **/
    Ice.ObjectAdapterIdInUseException = Slice.defineLocalException(
        function(id, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.id = id !== undefined ? id : "";
        },
        Ice.LocalException,
        "Ice::ObjectAdapterIdInUseException");

    /**
     * This exception is raised if no suitable endpoint is available.
     * 
     **/
    Ice.NoEndpointException = Slice.defineLocalException(
        function(proxy, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.proxy = proxy !== undefined ? proxy : "";
        },
        Ice.LocalException,
        "Ice::NoEndpointException");

    /**
     * This exception is raised if there was an error while parsing an
     * endpoint.
     * 
     **/
    Ice.EndpointParseException = Slice.defineLocalException(
        function(str, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.str = str !== undefined ? str : "";
        },
        Ice.LocalException,
        "Ice::EndpointParseException");

    /**
     * This exception is raised if there was an error while parsing an
     * endpoint selection type.
     * 
     **/
    Ice.EndpointSelectionTypeParseException = Slice.defineLocalException(
        function(str, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.str = str !== undefined ? str : "";
        },
        Ice.LocalException,
        "Ice::EndpointSelectionTypeParseException");

    /**
     * This exception is raised if there was an error while parsing a
     * version.
     * 
     **/
    Ice.VersionParseException = Slice.defineLocalException(
        function(str, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.str = str !== undefined ? str : "";
        },
        Ice.LocalException,
        "Ice::VersionParseException");

    /**
     * This exception is raised if there was an error while parsing a
     * stringified identity.
     * 
     **/
    Ice.IdentityParseException = Slice.defineLocalException(
        function(str, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.str = str !== undefined ? str : "";
        },
        Ice.LocalException,
        "Ice::IdentityParseException");

    /**
     * This exception is raised if there was an error while parsing a
     * stringified proxy.
     * 
     **/
    Ice.ProxyParseException = Slice.defineLocalException(
        function(str, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.str = str !== undefined ? str : "";
        },
        Ice.LocalException,
        "Ice::ProxyParseException");

    /**
     * This exception is raised if an illegal identity is encountered.
     * 
     **/
    Ice.IllegalIdentityException = Slice.defineLocalException(
        function(id, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.id = id !== undefined ? id : new Ice.Identity();
        },
        Ice.LocalException,
        "Ice::IllegalIdentityException");

    /**
     * This exception is raised to reject an illegal servant (typically
     * a null servant)
     * 
     **/
    Ice.IllegalServantException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.reason = reason !== undefined ? reason : "";
        },
        Ice.LocalException,
        "Ice::IllegalServantException");

    /**
     * This exception is raised if a request failed. This exception, and
     * all exceptions derived from {@link RequestFailedException}, are
     * transmitted by the Ice protocol, even though they are declared
     * <tt>local</tt>.
     * 
     **/
    Ice.RequestFailedException = Slice.defineLocalException(
        function(id, facet, operation, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.id = id !== undefined ? id : new Ice.Identity();
            this.facet = facet !== undefined ? facet : "";
            this.operation = operation !== undefined ? operation : "";
        },
        Ice.LocalException,
        "Ice::RequestFailedException");

    /**
     * This exception is raised if an object does not exist on the server,
     * that is, if no facets with the given identity exist.
     * 
     **/
    Ice.ObjectNotExistException = Slice.defineLocalException(
        function(id, facet, operation, _cause)
        {
            Ice.RequestFailedException.call(this, id, facet, operation, _cause);
        },
        Ice.RequestFailedException,
        "Ice::ObjectNotExistException");

    /**
     * This exception is raised if no facet with the given name exists,
     * but at least one facet with the given identity exists.
     * 
     **/
    Ice.FacetNotExistException = Slice.defineLocalException(
        function(id, facet, operation, _cause)
        {
            Ice.RequestFailedException.call(this, id, facet, operation, _cause);
        },
        Ice.RequestFailedException,
        "Ice::FacetNotExistException");

    /**
     * This exception is raised if an operation for a given object does
     * not exist on the server. Typically this is caused by either the
     * client or the server using an outdated Slice specification.
     * 
     **/
    Ice.OperationNotExistException = Slice.defineLocalException(
        function(id, facet, operation, _cause)
        {
            Ice.RequestFailedException.call(this, id, facet, operation, _cause);
        },
        Ice.RequestFailedException,
        "Ice::OperationNotExistException");

    /**
     * This exception is raised if a system error occurred in the server
     * or client process. There are many possible causes for such a system
     * exception. For details on the cause, {@link SyscallException#error}
     * should be inspected.
     * 
     **/
    Ice.SyscallException = Slice.defineLocalException(
        function(error, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.error = error !== undefined ? error : 0;
        },
        Ice.LocalException,
        "Ice::SyscallException");

    /**
     * This exception indicates socket errors.
     * 
     **/
    Ice.SocketException = Slice.defineLocalException(
        function(error, _cause)
        {
            Ice.SyscallException.call(this, error, _cause);
        },
        Ice.SyscallException,
        "Ice::SocketException");

    /**
     * This exception indicates file errors.
     * 
     **/
    Ice.FileException = Slice.defineLocalException(
        function(error, path, _cause)
        {
            Ice.SyscallException.call(this, error, _cause);
            this.path = path !== undefined ? path : "";
        },
        Ice.SyscallException,
        "Ice::FileException");

    /**
     * This exception indicates connection failures.
     * 
     **/
    Ice.ConnectFailedException = Slice.defineLocalException(
        function(error, _cause)
        {
            Ice.SocketException.call(this, error, _cause);
        },
        Ice.SocketException,
        "Ice::ConnectFailedException");

    /**
     * This exception indicates a connection failure for which
     * the server host actively refuses a connection.
     * 
     **/
    Ice.ConnectionRefusedException = Slice.defineLocalException(
        function(error, _cause)
        {
            Ice.ConnectFailedException.call(this, error, _cause);
        },
        Ice.ConnectFailedException,
        "Ice::ConnectionRefusedException");

    /**
     * This exception indicates a lost connection.
     * 
     **/
    Ice.ConnectionLostException = Slice.defineLocalException(
        function(error, _cause)
        {
            Ice.SocketException.call(this, error, _cause);
        },
        Ice.SocketException,
        "Ice::ConnectionLostException");

    /**
     * This exception indicates a DNS problem. For details on the cause,
     * {@link DNSException#error} should be inspected.
     * 
     **/
    Ice.DNSException = Slice.defineLocalException(
        function(error, host, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.error = error !== undefined ? error : 0;
            this.host = host !== undefined ? host : "";
        },
        Ice.LocalException,
        "Ice::DNSException");

    /**
     * This exception indicates a request was interrupted.
     * 
     **/
    Ice.OperationInterruptedException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.LocalException.call(this, _cause);
        },
        Ice.LocalException,
        "Ice::OperationInterruptedException");

    /**
     * This exception indicates a timeout condition.
     * 
     **/
    Ice.TimeoutException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.LocalException.call(this, _cause);
        },
        Ice.LocalException,
        "Ice::TimeoutException");

    /**
     * This exception indicates a connection establishment timeout condition.
     * 
     **/
    Ice.ConnectTimeoutException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.TimeoutException.call(this, _cause);
        },
        Ice.TimeoutException,
        "Ice::ConnectTimeoutException");

    /**
     * This exception indicates a connection closure timeout condition.
     * 
     **/
    Ice.CloseTimeoutException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.TimeoutException.call(this, _cause);
        },
        Ice.TimeoutException,
        "Ice::CloseTimeoutException");

    /**
     * This exception indicates that a connection has been shut down because it has been
     * idle for some time.
     * 
     **/
    Ice.ConnectionTimeoutException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.TimeoutException.call(this, _cause);
        },
        Ice.TimeoutException,
        "Ice::ConnectionTimeoutException");

    /**
     * This exception indicates that an invocation failed because it timed
     * out.
     * 
     **/
    Ice.InvocationTimeoutException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.TimeoutException.call(this, _cause);
        },
        Ice.TimeoutException,
        "Ice::InvocationTimeoutException");

    /**
     * This exception indicates that an asynchronous invocation failed
     * because it was canceled explicitly by the user using the
     * <tt>Ice::AsyncResult::cancel</tt> method.
     * 
     **/
    Ice.InvocationCanceledException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.LocalException.call(this, _cause);
        },
        Ice.LocalException,
        "Ice::InvocationCanceledException");

    /**
     * A generic exception base for all kinds of protocol error
     * conditions.
     * 
     **/
    Ice.ProtocolException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.reason = reason !== undefined ? reason : "";
        },
        Ice.LocalException,
        "Ice::ProtocolException");

    /**
     * This exception indicates that a message did not start with the expected
     * magic number ('I', 'c', 'e', 'P').
     * 
     **/
    Ice.BadMagicException = Slice.defineLocalException(
        function(reason, badMagic, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
            this.badMagic = badMagic !== undefined ? badMagic : null;
        },
        Ice.ProtocolException,
        "Ice::BadMagicException");

    /**
     * This exception indicates an unsupported protocol version.
     * 
     **/
    Ice.UnsupportedProtocolException = Slice.defineLocalException(
        function(reason, bad, supported, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
            this.bad = bad !== undefined ? bad : new Ice.ProtocolVersion();
            this.supported = supported !== undefined ? supported : new Ice.ProtocolVersion();
        },
        Ice.ProtocolException,
        "Ice::UnsupportedProtocolException");

    /**
     * This exception indicates an unsupported data encoding version.
     * 
     **/
    Ice.UnsupportedEncodingException = Slice.defineLocalException(
        function(reason, bad, supported, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
            this.bad = bad !== undefined ? bad : new Ice.EncodingVersion();
            this.supported = supported !== undefined ? supported : new Ice.EncodingVersion();
        },
        Ice.ProtocolException,
        "Ice::UnsupportedEncodingException");

    /**
     * This exception indicates that an unknown protocol message has been received.
     * 
     **/
    Ice.UnknownMessageException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
        },
        Ice.ProtocolException,
        "Ice::UnknownMessageException");

    /**
     * This exception is raised if a message is received over a connection
     * that is not yet validated.
     * 
     **/
    Ice.ConnectionNotValidatedException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
        },
        Ice.ProtocolException,
        "Ice::ConnectionNotValidatedException");

    /**
     * This exception indicates that a response for an unknown request ID has been
     * received.
     * 
     **/
    Ice.UnknownRequestIdException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
        },
        Ice.ProtocolException,
        "Ice::UnknownRequestIdException");

    /**
     * This exception indicates that an unknown reply status has been received.
     * 
     **/
    Ice.UnknownReplyStatusException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
        },
        Ice.ProtocolException,
        "Ice::UnknownReplyStatusException");

    /**
     * This exception indicates that the connection has been gracefully shut down by the
     * server. The operation call that caused this exception has not been
     * executed by the server. In most cases you will not get this
     * exception, because the client will automatically retry the
     * operation call in case the server shut down the connection. However,
     * if upon retry the server shuts down the connection again, and the
     * retry limit has been reached, then this exception is propagated to
     * the application code.
     * 
     **/
    Ice.CloseConnectionException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
        },
        Ice.ProtocolException,
        "Ice::CloseConnectionException");

    /**
     * This exception is raised by an operation call if the application
     * forcefully closes the connection {@link Connection#close}.
     * 
     * @see Connection#close
     * 
     **/
    Ice.ForcedCloseConnectionException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
        },
        Ice.ProtocolException,
        "Ice::ForcedCloseConnectionException");

    /**
     * This exception indicates that a message size is less
     * than the minimum required size.
     * 
     **/
    Ice.IllegalMessageSizeException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
        },
        Ice.ProtocolException,
        "Ice::IllegalMessageSizeException");

    /**
     * This exception indicates a problem with compressing or uncompressing data.
     * 
     **/
    Ice.CompressionException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
        },
        Ice.ProtocolException,
        "Ice::CompressionException");

    /**
     * A datagram exceeds the configured size.
     * 
     * This exception is raised if a datagram exceeds the configured send or receive buffer
     * size, or exceeds the maximum payload size of a UDP packet (65507 bytes).
     * 
     **/
    Ice.DatagramLimitException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
        },
        Ice.ProtocolException,
        "Ice::DatagramLimitException");

    /**
     * This exception is raised for errors during marshaling or unmarshaling data.
     * 
     **/
    Ice.MarshalException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.ProtocolException.call(this, reason, _cause);
        },
        Ice.ProtocolException,
        "Ice::MarshalException");

    /**
     * This exception is raised if inconsistent data is received while unmarshaling a proxy.
     * 
     **/
    Ice.ProxyUnmarshalException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.MarshalException.call(this, reason, _cause);
        },
        Ice.MarshalException,
        "Ice::ProxyUnmarshalException");

    /**
     * This exception is raised if an out-of-bounds condition occurs during unmarshaling.
     * 
     **/
    Ice.UnmarshalOutOfBoundsException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.MarshalException.call(this, reason, _cause);
        },
        Ice.MarshalException,
        "Ice::UnmarshalOutOfBoundsException");

    /**
     * This exception is raised if no suitable object factory was found during
     * unmarshaling of a Slice class instance.
     * 
     * @see ObjectFactory
     * @see Communicator#addObjectFactory
     * @see Communicator#findObjectFactory
     * 
     **/
    Ice.NoObjectFactoryException = Slice.defineLocalException(
        function(reason, type, _cause)
        {
            Ice.MarshalException.call(this, reason, _cause);
            this.type = type !== undefined ? type : "";
        },
        Ice.MarshalException,
        "Ice::NoObjectFactoryException");

    /**
     * This exception is raised if the type of an unmarshaled Slice class instance does
     * not match its expected type.
     * This can happen if client and server are compiled with mismatched Slice
     * definitions or if a class of the wrong type is passed as a parameter
     * or return value using dynamic invocation. This exception can also be
     * raised if IceStorm is used to send Slice class instances and
     * an operation is subscribed to the wrong topic.
     * 
     **/
    Ice.UnexpectedObjectException = Slice.defineLocalException(
        function(reason, type, expectedType, _cause)
        {
            Ice.MarshalException.call(this, reason, _cause);
            this.type = type !== undefined ? type : "";
            this.expectedType = expectedType !== undefined ? expectedType : "";
        },
        Ice.MarshalException,
        "Ice::UnexpectedObjectException");

    /**
     * This exception is raised when Ice receives a request or reply
     * message whose size exceeds the limit specified by the
     * <tt>Ice.MessageSizeMax</tt> property.
     * 
     **/
    Ice.MemoryLimitException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.MarshalException.call(this, reason, _cause);
        },
        Ice.MarshalException,
        "Ice::MemoryLimitException");

    /**
     * This exception is raised when a string conversion to or from UTF-8
     * fails during marshaling or unmarshaling.
     * 
     **/
    Ice.StringConversionException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.MarshalException.call(this, reason, _cause);
        },
        Ice.MarshalException,
        "Ice::StringConversionException");

    /**
     * This exception indicates a malformed data encapsulation.
     * 
     **/
    Ice.EncapsulationException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.MarshalException.call(this, reason, _cause);
        },
        Ice.MarshalException,
        "Ice::EncapsulationException");

    /**
     * This exception is raised if an unsupported feature is used. The
     * unsupported feature string contains the name of the unsupported
     * feature
     * 
     **/
    Ice.FeatureNotSupportedException = Slice.defineLocalException(
        function(unsupportedFeature, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.unsupportedFeature = unsupportedFeature !== undefined ? unsupportedFeature : "";
        },
        Ice.LocalException,
        "Ice::FeatureNotSupportedException");

    /**
     * This exception indicates a failure in a security subsystem,
     * such as the IceSSL plug-in.
     * 
     **/
    Ice.SecurityException = Slice.defineLocalException(
        function(reason, _cause)
        {
            Ice.LocalException.call(this, _cause);
            this.reason = reason !== undefined ? reason : "";
        },
        Ice.LocalException,
        "Ice::SecurityException");

    /**
     * This exception indicates that an attempt has been made to
     * change the connection properties of a fixed proxy.
     * 
     **/
    Ice.FixedProxyException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.LocalException.call(this, _cause);
        },
        Ice.LocalException,
        "Ice::FixedProxyException");

    /**
     * Indicates that the response to a request has already been sent;
     * re-dispatching such a request is not possible.
     * 
     **/
    Ice.ResponseSentException = Slice.defineLocalException(
        function(_cause)
        {
            Ice.LocalException.call(this, _cause);
        },
        Ice.LocalException,
        "Ice::ResponseSentException");
/* slice2js browser-bundle-skip */
    exports.Ice = Ice;
/* slice2js browser-bundle-skip-end */
/* slice2js browser-bundle-skip */
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));
/* slice2js browser-bundle-skip-end */
